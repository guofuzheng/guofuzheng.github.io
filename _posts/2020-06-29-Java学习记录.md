---
layout:     post                    # 使用的布局（不需要改）
title:      Java学习记录              # 标题 
subtitle:   Java学习记录 #副标题
date:       2020-06-29            # 时间
author:     GFZ                     # 作者
header-img: img/post-bg-debug.png    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - Java
---
# Java学习记录
1. JVM（Java virtual machine）Java虚拟机
2. 左移操作就是不断地乘以2，右移操作就是不断地除以2
3. 位操作就是将数据转换为二进制，然后按位进行操作：与、或、异或以及非
4. 浮点数虽然可以表示的范围大，但是浮点数无法精确地表示
5. 由于浮点数存在误差，所以在比较时，可以用两者之差的绝对值是否小于一个很小的数进行比较
```Java
double r = Math.abs( x - y ) 
if ( r < 0.00001){
	//相等
}
else{
	//不相等
}
```
6. Java中的短路运算，是在于布尔值类型，如果&&前面的为`False`，那么后面则不再计算；如果\|\|前面的为`True`，那么后面的也不再计算。
7. Java的三目运算符，`a?b:c`判断a成不成立，如果成立则为`b`，如果不成立则为`c`。
8. Java在内存总是使用Unicode编码保存字符，中文和英文的一个字符都可以使用`char`来表示，要现实Unicode的编码则转换为·`int`型。
9. Java在连接字符串时，会将其他类型的先转为字符串类型，然后再拼接。就不会像Python一样要先转换。
10. 多行字符串```"""......."""```
11. 若要使用多行文本输出，需要在控制台编译时`javac --source 版本号 --enable-preview 文件`。执行时`java --enable-preview 文件`.
12. Java定义数组的方式，```int[] var = new int[5];```。直接输出`var`输出的应该是内存地址。Python会直接把数据输出来。
13. ```int x = 1; x = 2;```其中x的值并没有变，只是指向的内存地址变了。不能再通过x来访问`1`。针对数组也是同样的，数组的大小不可变，只是指向的内存地址换了。
14. Java中字符串、数组是引用类型，引用类型和正常的区别是什么？`基本类型`的内容是存在在栈里，而`引用类型`的内容是存放在堆里，栈里存放的只是内存地址。
15. Java中的堆和栈又有什么区别呢？`栈内存的定义：栈内存是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量，先加载函数才能进行局部变量的定义，所以方法先进栈，然后定义变量，变量都有自己的作用域，一旦离开作用域，变量就会被释放，栈内存的更新速度很快，因为局部变量的声明周期都很短`。`堆内存的定义：堆中存储的都是数组和对象，凡是new建立的都是在堆中，堆中存放的都是实体，如果一个数据消失，这个实体还在，那么久还可以使用`。
16. 引用类型使用`==`是肯定不相等的，因为两个对象的地址不同，引用类型的大小比较可以使用`equals()`实现。如`s1.equals(s2)`。
17. for循环内先赋值，再判断，最后执行操作。
18. `break`和`continue`的区别：`break`执行时会提前结束本次循环，就是一次也不执行了；而`continue`则是结束本次执行，本次`continue`下的所有操作都不执行，继续执行下一次的操作。
19. `Arrays.toString(para)`可以把数组内的内容转换为字符串输出，因此也不用循环打印。
20. 使用`Arrays.sort()`处理基础类型时直接改变了内存中的数据，而引用类型的排序则是仅仅改变了引用的地址。
21. Java里的`Arrays.sort()`与Python里的一样，没有返回值，直接对数组进行操作。`Arrays.sort(a);`。
22. Java与C++在数组上的一个区别是，二维数组中每个元素的长度可以不同。
23. `Person ming = new Person()`中真正实例化的是`new Person()`，应该是实例化完存于堆内存中，只是一个变量名指向这个实例化的对象。
24. Java中同样可以通过`s1.strip()`去掉首尾空格。
25. 可变参数可以用`类型...`来定义，相当于数组，他可以确保不传入空值。
26. 基本类型参数的传递，是调用方值的复制，就是复制内存里的值，而引用类型则不是。
27. 创建实例的时候，实际上是通过构造方法来初始化实例的，初始化变量啥的可以在构造函数里进行。
28. 在类中的构造函数中未初始化字段时，引用类型的字段默认是null，数值类型的用默认值，int类型的为0，bool类型的默认是false。
29. 在Java中，对象的实例化的顺序为：先初始化字段，即属性的定义初始化，然后按照构造函数中进行初始化。
30. 同时也可以在一个对象中，构造多个构造函数，在`new()`实例化时，会按照参数数量，位置，类型来区分。
31. 方法重载的目的是，功能类似的方法使用同一个名字，更容易理解和记住。方法重载的返回值类型都是相同的。
32. 子类继承父类时，无法继承父类的构造函数，同时父类的private字段，子类也无法访问，protected字段，子类可以访问。
33. 子类在继承父类时，可以使用父类的构造函数，需要在子类的构造函数中加入`super(父类构造函数的参数)`。
34. 向上转型，其实就是把子类转换为更抽象的父类。没法使用子类的方法了。
35. 向下转型，就是把父类转换为更加具体的子类。
36. 若子类B继承父类A，同时覆写了其中的方法。在实例化A后，用B类型的变量引用A，在执行该方法时，还是会调用B类型的方法。即Java的实例化方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。即多态，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。
37. 子类覆写的方法中，若想调用父类被覆写的方法，可以用`super.方法()`。
38. 父类若不想子类覆写该方法，可以`public final String toString()`。
39. 如果不想任何一个子类继承该类，则可以用`final`而不是`public`等来修饰。
40. 如果父类的方法，本身没有实际意义，只是让子类去覆写它，那么就可以把它声明为抽象方法，这个类也是抽象类。必须把类声明为抽象类，否则无法编译。
41. 在抽象类中，抽象方法本质上是定义接口规范，规定高层类的接口，从而保证所有子类都有相同的接口实现，如果一个抽象类没有字段，所有方法全部都是抽象方法，就可以把该抽象类改写为接口`interface`。`interface Person{}`。
42. 所谓接口，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有，因为接口定义的所有方法的默认值都是`public abstract`，所以这两个修饰符写不写都一样。
43. 当一个class去实现一个借口interface时，需要使用implement关键字。如`class Student implements Person{}`。
44. 在使用类去实现一个接口时，需要方法名以及形参都相同，否则会出错。
45. `default`方法的目的是，当我我们需要给接口新增一个方法时，会涉及到修改所有子类，如果新增的是`default`方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。
46. 在使用`default`方法时，default方法必须有一个函数体而不是简单的方法声明。
47. 在一个`class`中定义的字段，我们称之为实例字段，实例字段的特点是，每个实例都有独立的字段，各个实例的同名字段互不影响。还有一种字段使用`static`修饰的字段，成为静态字段。实例字段在每个实例中都有自己的独立空间，而静态字段则不是，每个实例共享的空间，就是一个修改了，所有的都被修改了。
48. 虽然实例可以访问静态字段，但是他们其实都是指向的类的静态字段，所有实例都共享一个静态字段。因此，不推荐使用实例变量.静态字段来访问静态变量，推荐使用类名.静态字段来访问。在代码中，实例能够访问静态变量其实还是因为代码转换为`类名.静态变量`来访问。
49. 与静态变量类似的是，静态方法不属于实例而是属于类，因此，静态方法无法访问实例中的字段，也无法访问this变量。通过实例变量名可以访问静态方法，只是因为代码转换为类名.静态方法。同时`this`指向的不是类而是当前实例。
50. 接口中不可以定义实例字段，但是可以使用静态变量，使用`final`修饰。
51. 每个Java程序在执行时，都会去寻找那个`main`方法，但是这个`main`方法为什么需要是静态方法呢？首先，Java程序执行时的入口函数为`main`函数，在执行时会去找`main`，其次，之所以是静态方法是因为静态方法存在静态存储区内，不需要实例化，如果`main`函数需要实例化，就会出现很多问题，也就始终无法执行。
52. 位于同一个包的类，可以访问包作用域的方法。
53. `final`修饰符可以修饰`class`，防止被继承；可以修饰`method`防止被覆写；可以修饰`field`防止被重新赋值。
54. 两个字符串 进行比较，必须总是使用`equals`进行比较。
55. 是否包含子串`s1.contains(s2)`
56. `s1.trim()`可以去除字符串首尾的空白字符包括转义的，而`s1.strip()`可以去除首尾空白字符，它还可以去吃中文的空格。这两者都没有改变原来的字符串，只是返回了一个新的字符串。
57. `isEmpty()`和`isBlank()`分别用来判断字符串是否为空，以及是否是空白字符串。
58. 替换子串`s1.replace(a,b)`就是在s1中用b来替换a。
59. 可以使用`String.join(a,b)`即用`a`来连接`b`中的每一个元素。
60. 同时字符串还提供了`formatted`和`format`两种方法，`String a = "hi,%s,your age is %d";a.formatted("guo",25)`；`String.format("hi,%s,your age is %d","guo",25);`
61. 寻找在字符串中指定字符串的位置：`s1.indexOf(s2)`。寻找最后一个指定字符串的位置：`s1.lastIndexOf(s2)`。
62. 遇到的问题：数组类型和字符串类型都是引用类型，为什么数组在修改后地址不变，而字符串修改后地址改变？虽然数组和字符串都是引用类型，但是字符串对象声明时就是final,属于不变类，所以在修改时会复制一份，然后返回修改的地址。而数组则是在堆内存直接修改，因而地址不会改变。
63. 遇到的问题2：是不是只有`String`在实例化时，利用`char[]`数组时会复制一份，其他的引用类型在进行这种操作的时候是不是也有？
64. 关于创建新的变量，整型的如果使用`int a = 5;int b=5;`这样就是在`-128~127`范围内，其实是有一个缓存，这样的地址是相同的，如果在这个范围之外，就会地址不同。如果以对象的形式创建就是封箱，因为创建的是对象，是引用类型，地址就肯定不相同。
64. 为了能更高效地拼接字符串，Java还有`StringBuilder`，它是一个可变对象，可以预分配缓冲区，这样往`StringBuilder`中新增字符时，不会创建新的临时对象，`StringBuilder s = new StringBuilder(1024);s.append(',');`。它可以一直`append`，究其原因是，它在调用一次后，返回的是`this`。
65. `StringJoiner`可传入三个参数`("连接字符","开头字符","结尾字符")`。
66. 如果想要把基本类型`int`转换为引用类型`Integer`，那么这个`Integer`就是`int`类型的包装类。直接把`int`转换为`Integer`的成为自动装箱，反过来成为自动拆箱。`int n = 5;Integer m = Integer.valueOf(n);int x = m.intValue();`。
67. `Integer n  = Integer.valueOf(100)`称为静态工厂方法，它尽可能的返回缓存的实例以节省内存。
68. 一个类中关于一个字段的读和写，这样的一组操作成为属性。只有读操作的成为只读属性，只有写操作的成为只写属性。
69. 枚举类型：`enum WeekDay{SUN,MON,TUE,WED,THU,FRI,SAT}`。首先enum本身带有类型信息，其次不可能引用到非枚举的值，最后不同类型的枚举不可以互相比较以及赋值。`enum`的比较可以用`==`，因为`enum`类型在内存中只有一个唯一实例，因此可以使用`==`来比较。
70. 可以通过`WeekDay.SUN.name()`获取枚举类型的字符串。也可以为枚举类型编写构造方法，字段和方法。构造方法声明为private()，字段声明为final()。
71. 记录类 `record`可以把一个类变成不变类。不变类有以下特点：首先定义class时使用的是`final`，无法派生子类。其次定义字段时使用的是`final`，保证创建后无法修改字段。
72. Java的捕获异常`try{}catch{}catch{}`，会根据从上到下匹配异常，匹配到某个异常，则执行相应语句，其之后的异常处理则不再匹配。所以子类应该在前面。
73. 在捕获异常后，会有不管有没有异常都要执行的语句，这时就可以用`try{}catch{}finally{}`写在`finally`中的即为不管有没有异常都要执行的语句。
74. 如果两种异常的处理方法是相同的，就可以写成这种形式`try{} catch{a|b}{} finally{}`。
75. 当某个方法抛出异常时，如果当前方法没有捕获异常，异常就会被抛到上层调用方法，直到遇到某个`try{} catch{}`为止。
76. 如果`catch`和`finally`都出现了异常，在`finally`抛出异常后，原来的`catch`中的异常就消失了，因为只能抛出一个异常，没有被抛出的异常成为被屏蔽的异常。
77. 当我们在代码中需要抛出异常时，尽量使用JDK已定义的异常类型。
78. `NullPointerException`是空指针异常，俗称`NPE`，如果一个对象为`NULL`调用方法或者访问字段就会产生`NPE`。`NPE`是一种代码逻辑错误，遇到`NPE`，遵循的原则是早暴露，早修复。
79. 如果一个Java对象可以持有若干其他Java对象，并对外提供访问接口，这种Java对象称为集合。
80. Java数组很明显可以看做一种集合，为什么有了数组还要使用其他集合类？因为数组初始化后，大小不可以改变，同时只能按照索引顺序存取。
81. Java标准库自带的Java.util提供了集合类：Collection，他是除了map之外所有集合类的根接口。Java的util包提供了以下三种类型的集合：List，Set，Map。List是一种有序列表的集合。Java集合的设计有几个特点：首先实现了接口与实现方法的分离；其次是支持泛型，可以限制在一个集合中只能放入同一种数据类型的元素；最后，集合的访问都是通过迭代器来实现的。
82. List就是跟Python中的基本差不多，他有`ArrayList`和`LinkedList`两种，前者就是类似数组的形式，只是不需要管具体数字是怎么移动的，后者是类似于链表的形式。通常情况下，总是优先使用`ArrayList`。
83. 如果需要用初始值创建List，可以通过`List<> list = List.of(1,2,5)`。这个方法不接受`NULL`，会报`NPE`的错误。
84. 最好使用迭代器来访问List，Iterator对象知道如何访问一个List，不管是`ArrayList`还是`LinkedList`，并且不同的`List`类型，返回的`Iterator`返回的对象也是不同的，但总是有最高的访问效率。  
```
List<Integer> list = List.of(1,2,4);
        for (Iterator<Integer> it = list.iterator();it.hasNext();){
            Integer s = it.next();//这个it,next()中的it 感觉指向的是首地址的感觉。
            System.out.println(s);
        }
``` 

86. String[] 表示声明的是一个String类型的数组,Object[]声明的是一个Object类型的数组。因为所有类都继承自Object,所以Object[]可以存放所有类型的对象,String[]只能存放String类型的对象。
87. 可以用这种方式`List<Integer> intListA = new LinkedList<Integer>();`定义List，也可以使用这种`List<Integer> intListA = List.of(1,2,3);`但是后者的元素不可修改，可能也是不变类类型的。
88. 要把数组转换为List，其实很简单`Integer[] a = new Integer[]{1,2,3,4};List<Integer> aInteger = List.of(a);`。
89. List和String中的`contains`方法都采用的是`equals`方法进行比较而不是`==`。
90. `instanceof `是用来之处对象是否是特定类的实体，`intanceof`通过返回一个布尔值，来指出这个对象是否是这个特定类或者它的子类的一个实例。
91. `Map`中不存在重复的Key，因为放入相同的Key，只会把原有的`Key-Value`对应的`Value`换掉。
92. `Map`可以用如下方式来定义`Map<String,Person> map = new HashMap<>();`，加入数据可以用`map.put(String,Person)`，获取数据可以用`map.get(String)`。
93. 同时遍历`key`和`value`，可以使用`for each`遍历`Map`对象的`entrySet()`集合。它包含每一个`key-value`映射。`for (Map.Entry<String,Person> entry:map.entrySet()){}`
94. 在`Map`内部，关于`key`的比较，是通过`equals()`实现的，经常使用`String`作为`Key`，如果放入的`Key`是我们自己定义的类，那么就需要正确地覆写`equals`方法。通过`Key`计算索引的方式就是调用`Key`对象的`hashCode()`方法，它返回一个`int`整数，`HashMap`正是通过这种方法直接定位`Key`所对应的`Value`的位置，进而返回`value`。
95. 正确使用`Map`必须保证：首先，作为`key`对象必须正确覆写`equals()`方法`key`实例调用`equals()`必须返回true。其次，作为`key`对象还必须正确覆写`hashCode()`方法，如果两个对象相同，那么两个对象的`hashcode`必须相等，如果两个对象不同，那么两个对象的`hashcode`最好不相等。
96. 编写`equals`和`hashCode`遵循的原则是：`equals`用于比较的每一个字段，都必须在`hashCode`中用于计算；`equals`没有用于比较的字段，绝不可以放在`hashCode`中用于计算。
97. 为什么`EnumMap<>()`要传入一个class 参数呢？`HashMap`就不需要？
98. `HashMap`内部是无序的，如果需要对`Map`的内部进行排序的话，可以使用`SortedMap`但是，这个是个接口，可以使用`TreeMap<>()`，在使用`TreeMap`时，放入的`key`必须实现`Comparable`接口，那么必须在创建`TreeMap`时同时指定一个自定义排序算法。`Map<Person,Integer> map = new TreeMap<>(new comparator<Person>(){public int compare(Person p1,Person p2){return p1.name.compareTo(p2.name);}})`。
99. `Comparator`接口要求实现一个比较方法，它负责比较传入的两个元素`a`和`b`，如果`a<b`，则返回负数，通常是`-1`；如果`a==b`，则返回`0`；如果`a>b`，则返回正数，通常是`1`。`TreeMap`并未覆写`equals`和`hashcode`。因为`TreeMap`不需要`equals`和`hashcode`。
100. 在文件进行输出写入时，需要进行异常捕获。
101. `set`相当于只存储`key`，不存储`value`的map,同样的，需要正确地覆写`equals()`和`hashCode()`。如果我们只需要存储不重复的`key`，并不需要存储映射的`value`，那么就可以使用`set`。
102. 队列`Queue`实现了一个先进先出的数据结构。通过`add()/offer()`方法将元素添加到队尾；通过`remove()/poll()`从队首获取元素并删除；通过`element()/peek()`获取队首元素但并不删除。
103. `Queue`的方法中：如果调用`add()`，如果添加失败，会返回异常。如果调用`offer()`来添加元素，当添加失败时，不会返回异常，而是返回false。如果使用`remove()`来删除元素，如果删除失败，会返回异常。如果使用`poll()`来删除元素，如果删除失败，不会返回异常只会返回`null`。
104. `PriorityQueue`和`Queue`的区别在于，它的出队顺序和元素的优先级有关，对`PriorityQueue`而言，使用`remove()`和`poll()`返回的总是优先级最高的元素。
105. 因为`PriorityQueue`根据优先级决定出队的顺序。因为需要比较优先级，所以需要`comparable`接口，`PriorityQueue`允许我们提供一个`comparator`对象来判断两个元素的顺序。
106. `Queue`是队列，只能一头进另一头出。但是Deque(Double Ended Queue)允许两头都进，两头都出。
107. `Deque`实现双端队列，他的功能是：既可以添加到队首也可以添加到队尾。同时，既可以从队首获取元素也可以从队尾获取元素。
108. `Deque`添加元素到队首，`addFirst()/offerFirst()`；取队首元素但是不删除，`getFirst()/peekFirst()`，取队首元素且删除，`removeFirst()/pollFirst()`。添加元素到队尾，`addLast()/offerLast()`，取队尾元素但是不删除，`getLast()/peekLast()`，去队尾元素且删除，`removeLast()/pollLast()`。
109. 队列是一种`先进先出FIFO`，还有栈，但是Java中没有栈这一实现，是使用的`Deque`来替代的，`Stack`只有入栈和出栈操作，元素压栈`s.push()`，元素出栈`s.pop()`，取栈顶元素但是不弹出`s.peek()`。 
110.在编写`Iterator`的时候，我们通常可以用一个内部类，来实现`Iterator`接口，这个内部类可以直接访问对应的外部类的所有字段和方法，`Iterator`是一种抽象的数据访问模型，使用`Iterator`的好处有：对任何对象都采用一种访问模型，调用者对内部结构一无所知，集合类返回的`iterator`对象知道如何迭代。
