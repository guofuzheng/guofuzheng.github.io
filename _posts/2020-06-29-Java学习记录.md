---
layout:     post                    # 使用的布局（不需要改）
title:      Java学习记录              # 标题 
subtitle:   Java学习记录 #副标题
date:       2020-06-29            # 时间
author:     GFZ                     # 作者
header-img: img/post-bg-debug.png    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - Java
---
# Java学习记录
1. JVM（Java virtual machine）Java虚拟机
2. 左移操作就是不断地乘以2，右移操作就是不断地除以2
3. 位操作就是将数据转换为二进制，然后按位进行操作：与、或、异或以及非
4. 浮点数虽然可以表示的范围大，但是浮点数无法精确地表示
5. 由于浮点数存在误差，所以在比较时，可以用两者之差的绝对值是否小于一个很小的数进行比较
```Java
double r = Math.abs( x - y ) 
if ( r < 0.00001){
	//相等
}
else{
	//不相等
}
```
6. Java中的短路运算，是在于布尔值类型，如果&&前面的为`False`，那么后面则不再计算；如果||前面的为`True`，那么后面的也不再计算。
7. Java的三目运算符，`a?b:c`判断a成不成立，如果成立则为`b`，如果不成立则为`c`。
8. Java在内存总是使用Unicode编码保存字符，中文和英文的一个字符都可以使用`char`来表示，要现实Unicode的编码则转换为·`int`型。
9. Java在连接字符串时，会将其他类型的先转为字符串类型，然后再拼接。就不会像Python一样要先转换。
10. 多行字符串```"""......."""```
11. 若要使用多行文本输出，需要在控制台编译时`javac --source 版本号 --enable-preview 文件`。执行时`java --enable-preview 文件`.
12. Java定义数组的方式，```int[] var = new int[5];```。直接输出`var`输出的应该是内存地址。Python会直接把数据输出来。
13. ```int x = 1; x = 2;```其中x的值并没有变，只是指向的内存地址变了。不能再通过x来访问`1`。针对数组也是同样的，数组的大小不可变，只是指向的内存地址换了。
14. Java中字符串、数组是引用类型，引用类型和正常的区别是什么？`基本类型`的内容是存在在栈里，而`引用类型`的内容是存放在堆里，栈里存放的只是内存地址。
15. Java中的堆和栈又有什么区别呢？`栈内存的定义：栈内存是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量，先加载函数才能进行局部变量的定义，所以方法先进栈，然后定义变量，变量都有自己的作用域，一旦离开作用域，变量就会被释放，栈内存的更新速度很快，因为局部变量的声明周期都很短`。`堆内存的定义：堆中存储的都是数组和对象，凡是new建立的都是在堆中，堆中存放的都是实体，如果一个数据消失，这个实体还在，那么久还可以使用`。
16. 引用类型使用`==`是肯定不相等的，因为两个对象的地址不同，引用类型的大小比较可以使用`equals()`实现。如`s1.equals(s2)`。
17. for循环内先赋值，再判断，最后执行操作。
18. `break`和`continue`的区别：`break`执行时会提前结束本次循环，就是一次也不执行了；而`continue`则是结束本次执行，本次`continue`下的所有操作都不执行，继续执行下一次的操作。
19. `Arrays.toString(para)`可以把数组内的内容转换为字符串输出，因此也不用循环打印。
20. 使用`Arrays.sort()`处理基础类型时直接改变了内存中的数据，而引用类型的排序则是仅仅改变了引用的地址。
21. Java里的`Arrays.sort()`与Python里的一样，没有返回值，直接对数组进行操作。`Arrays.sort(a);`。
22. Java与C++在数组上的一个区别是，二维数组中每个元素的长度可以不同。
23. `Person ming = new Person()`中真正实例化的是`new Person()`，应该是实例化完存于堆内存中，只是一个变量名指向这个实例化的对象。
24. Java中同样可以通过`s1.strip()`去掉首尾空格。
25. 可变参数可以用`类型...`来定义，相当于数组，他可以确保不传入空值。
26. 基本类型参数的传递，是调用方值的复制，就是复制内存里的值，而引用类型则不是。
27. 创建实例的时候，实际上是通过构造方法来初始化实例的，初始化变量啥的可以在构造函数里进行。
28. 在类中的构造函数中未初始化字段时，引用类型的字段默认是null，数值类型的用默认值，int类型的为0，bool类型的默认是false。
29. 在Java中，对象的实例化的顺序为：先初始化字段，即属性的定义初始化，然后按照构造函数中进行初始化。
30. 同时也可以在一个对象中，构造多个构造函数，在`new()`实例化时，会按照参数数量，位置，类型来区分。
31. 方法重载的目的是，功能类似的方法使用同一个名字，更容易理解和记住。方法重载的返回值类型都是相同的。
32. 子类继承父类时，无法继承父类的构造函数，同时父类的private字段，子类也无法访问，protected字段，子类可以访问。
33. 子类在继承父类时，可以使用父类的构造函数，需要在子类的构造函数中加入`super(父类构造函数的参数)`。
34. 向上转型，其实就是把子类转换为更抽象的父类。没法使用子类的方法了。
35. 向下转型，就是把父类转换为更加具体的子类。
36. 若子类B继承父类A，同时覆写了其中的方法。在实例化A后，用B类型的变量引用A，在执行该方法时，还是会调用B类型的方法。即Java的实例化方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。即多态，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。
37. 子类覆写的方法中，若想调用父类被覆写的方法，可以用`super.方法()`。
38. 父类若不想子类覆写该方法，可以`public final String toString()`。
39. 如果不想任何一个子类继承该类，则可以用`final`而不是`public`等来修饰。
40. 如果父类的方法，本身没有实际意义，只是让子类去覆写它，那么就可以把它声明为抽象方法，这个类也是抽象类。必须把类声明为抽象类，否则无法编译。
41. 在抽象类中，抽象方法本质上是定义接口规范，规定高层类的接口，从而保证所有子类都有相同的接口实现，如果一个抽象类没有字段，所有方法全部都是抽象方法，就可以把该抽象类改写为接口`interface`。`interface Person{}`。
42. 所谓接口，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有，因为接口定义的所有方法的默认值都是`public abstract`，所以这两个修饰符写不写都一样。
43. 当一个class去实现一个借口interface时，需要使用implement关键字。如`class Student implements Person{}`。
44. 在使用类去实现一个接口时，需要方法名以及形参都相同，否则会出错。
45. `default`方法的目的是，当我我们需要给接口新增一个方法时，会涉及到修改所有子类，如果新增的是`default`方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。
46. 在使用`default`方法时，default方法必须有一个函数体而不是简单的方法声明。
47. 在一个`class`中定义的字段，我们称之为实例字段，实例字段的特点是，每个实例都有独立的字段，各个实例的同名字段互不影响。还有一种字段使用`static`修饰的字段，成为静态字段。实例字段在每个实例中都有自己的独立空间，而静态字段则不是，每个实例共享的空间，就是一个修改了，所有的都被修改了。
48. 虽然实例可以访问静态字段，但是他们其实都是指向的类的静态字段，所有实例都共享一个静态字段。因此，不推荐使用实例变量.静态字段来访问静态变量，推荐使用类名.静态字段来访问。在代码中，实例能够访问静态变量其实还是因为代码转换为`类名.静态变量`来访问。
49. 与静态变量类似的是，静态方法不属于实例而是属于类，因此，静态方法无法访问实例中的字段，也无法访问this变量。通过实例变量名可以访问静态方法，只是因为代码转换为类名.静态方法。同时`this`指向的不是类而是当前实例。
50. 接口中不可以定义实例字段，但是可以使用静态变量，使用`final`修饰。
51. 每个Java程序在执行时，都会去寻找那个`main`方法，但是这个`main`方法为什么需要是静态方法呢？首先，Java程序执行时的入口函数为`main`函数，在执行时会去找`main`，其次，之所以是静态方法是因为静态方法存在静态存储区内，不需要实例化，如果`main`函数需要实例化，就会出现很多问题，也就始终无法执行。
52. 位于同一个包的类，可以访问包作用域的方法。
53. `final`修饰符可以修饰`class`，防止被继承；可以修饰`method`防止被覆写；可以修饰`field`防止被重新赋值。
54. 两个字符串 进行比较，必须总是使用`equals`进行比较。
55. 是否包含子串`s1.contains(s2)`
56. `s1.trim()`可以去除字符串首尾的空白字符包括转义的，而`s1.strip()`可以去除首尾空白字符，它还可以去吃中文的空格。这两者都没有改变原来的字符串，只是返回了一个新的字符串。
57. `isEmpty()`和`isBlank()`分别用来判断字符串是否为空，以及是否是空白字符串。
58. 替换子串`s1.replace(a,b)`就是在s1中用b来替换a。
59. 可以使用`String.join(a,b)`即用`a`来连接`b`中的每一个元素。
60. 同时字符串还提供了`formatted`和`format`两种方法，`String a = "hi,%s,your age is %d";a.formatted("guo",25)`；`String.format("hi,%s,your age is %d","guo",25);`
61. 寻找在字符串中指定字符串的位置：`s1.indexOf(s2)`。寻找最后一个指定字符串的位置：`s1.lastIndexOf(s2)`。
62. 遇到的问题：数组类型和字符串类型都是引用类型，为什么数组在修改后地址不变，而字符串修改后地址改变？虽然数组和字符串都是引用类型，但是字符串对象声明时就是`final`,属于不变类，所以在修改时会复制一份，然后返回修改的地址。而数组则是在堆内存直接修改，因而地址不会改变。
63. 遇到的问题2：是不是只有`String`在实例化时，利用`char[]`数组时会复制一份，其他的引用类型在进行这种操作的时候是不是也有？
64. 为了能更高效地拼接字符串，Java还有`StringBuilder`，它是一个可变对象，可以预分配缓冲区，这样往`StringBuilder`中新增字符时，不会创建新的临时对象，`StringBuilder s = new StringBuilder(1024);s.append(',');`。它可以一直`append`，究其原因是，它在调用一次后，返回的是`this`。
65. `StringJoiner`可传入三个参数`("连接字符","开头字符","结尾字符")`。
66. 如果想要把基本类型`int`转换为引用类型`Integer`，那么这个`Integer`就是`int`类型的包装类。直接把`int`转换为`Integer`的成为自动装箱，反过来成为自动拆箱。`int n = 5;Integer m = Integer.valueOf(n);int x = m.intValue();`。
67. `Integer n  = Integer.valueOf(100)`称为静态工厂方法，它尽可能的返回缓存的实例以节省内存。
68. 一个类中关于一个字段的读和写，这样的一组操作成为属性。只有读操作的成为只读属性，只有写操作的成为只写属性。
69. 枚举类型：`enum WeekDay{SUN,MON,TUE,WED,THU,FRI,SAT}`。首先enum本身带有类型信息，其次不可能引用到非枚举的值，最后不同类型的枚举不可以互相比较以及赋值。`enum`的比较可以用`==`，因为`enum`类型在内存中只有一个唯一实例，因此可以使用`==`来比较。
70. 可以通过`WeekDay.SUN.name()`获取枚举类型的字符串。也可以为枚举类型编写构造方法，字段和方法。构造方法声明为private()，字段声明为final()。
71. 记录类 `record`可以把一个类变成不变类。不变类有以下特点：首先定义class时使用的是`final`，无法派生子类。其次定义字段时使用的是`final`，保证创建后无法修改字段。
72. Java的捕获异常`try{}catch{}catch{}`，会根据从上到下匹配异常，匹配到某个异常，则执行相应语句，其之后的异常处理则不再匹配。所以子类应该在前面。
73. 在捕获异常后，会有不管有没有异常都要执行的语句，这时就可以用`try{}catch{}finally{}`写在`finally`中的即为不管有没有异常都要执行的语句。
74. 如果两种异常的处理方法是相同的，就可以写成这种形式`try{} catch{a|b}{} finally{}`。
75. 当某个方法抛出异常时，如果当前方法没有捕获异常，异常就会被抛到上层调用方法，直到遇到某个`try{} catch{}`为止。
76. 